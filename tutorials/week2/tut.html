<html lang="en">
<head>
  <title>Week 2 tutorial</title>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
</head>
<body>
<div style="margin: 20px;">

  <h1>Tutorial - Week 2</h1>

  <b>Tutorial subject to change</b>

  <h3>Question 1</h3>

  What is the difference between each kind of iterator?
  <ul>
    <li>Input iterator</li>
    <li>Output iterator</li>
    <li>Forward iterator</li>
    <li>Bidirectional iterator</li>
    <li>Random-access iterator</li>
  </ul>

  <hr>


  <h3>Question 2</h3>

  What is different about a const iterator?

  <hr>

  <h3>Question 3</h3>
  What kind of iterator is each of the following (and are the iterators const)?<br>
  Which of these will compile, and which of these will not?<br>
  Note: std::list is a doubly linked list, and std::forward_list is a singly linked list.
  <pre><code>
  const std::vector&lt;int&gt vec;
  std::list&lt;int&gt; li;
  std::forward_list&lt;double&gt; forward_li;
  std::string s;

  vec.begin();
  vec.cbegin();
  *vec.begin()++;
  li.cbegin();
  li.rbegin();
  forward_li.cbegin();
  *forward_li.cbegin()++;
  forward_li.crbegin();
  s.begin();
  std::back_inserter(vec);
  std::back_inserter(li);
  std::istream_iterator&lt;int&gt;(std::cin);
  std::ostream_iterator&lt;int&gt;(std::cout, " ");
</code></pre>

  <details>
    <summary>Answers</summary>
    <pre><code>
  const std::vector&lt;int&gt vec;
  std::list&lt;int&gt; li;
  std::forward_list&lt;double&gt; forward_li;
  std::string s;

  vec.begin(); // Random-access const iterator (compiler always prefers the const overload over the non-const)
  vec.cbegin(); // Random-acess const iterator
  *vec.begin()++; // Fails to compile. It needs the non-const overload, but the vector is const.
  li.cbegin(); // Bidirectional const iterator
  li.rbegin(); // Bidirectional iterator, but goes in opposite direction
  forward_li.cbegin(); // Forward const iterator
  *forward_li.cbegin()++; // Fails to compile. Cannot modify value of const iterator
  forward_li.crbegin(); // Fails to compile. Cannot get a reverse iterator for a forward_iterator
  s.begin(); // Random-acess const iterator
  std::back_inserter(vec); // Fails to compile. Cannot provide a back inserter for a const container
  std::back_inserter(li); // Output iterator
  std::istream_iterator&lt;int&gt;(std::cin); // Input iterator
  std::ostream_iterator&lt;int&gt;(std::cout, " "); // Output iterator
</code></pre>

  </details>

  <hr>

  <h3>Question 4</h3>
  What is the relationship between containers, iterators, and algorithms?<br>
  Why is this relationship so important, and how does it help us as programmers?<br>
  How does this relate to the DRY (don't repeat yourself) principle?

  <h3>Question 5</h3>
  <ol>
    <li>Use standard algorithms to read a list of newline-seperated words from a file into a vector (hint: see std::istream_iterator)
    </li>
    <li>Write a function that:
      <ol>
        <li>Takes in the word list and a string</li>
        <li>Uses standard algorithms to split the string into words, filtered to only words that are
          in the word dict, and reconstruct this into a string (hint: see std::istringstream,
          std::istream_iterator, std::copy_if, std::ostringstream, and std::ostream_iterator)
        </li>
      </ol>
    </li>
    <li>Discuss why separating your functions you want to test is a good idea</li>
    <li>Write some tests for your code.</li>
    <li>Assume now that the word list and strings are both very large. Discuss how we could make
      this code run much faster (hint: a different data structure may be required. Tutors, students
      should know the data type, but not what it is called in C++)
    </li>
    <li>Use the algorithms library to make your code run much faster</li>
    <li>Discuss the effect the use of the algorithms library had on the quantity of the tests you
      had to change, and the depth of the testing required.
    </li>
    <li>Discuss the effect the use of automatic type deduction (through the use of auto keyword, and
      by not having to declare types at all when calling functions) on the quantity of code you had
      to change, and the depth of the testing required.
    </li>
  </ol>

  <details>
    <summary>Outline of possible solutions</summary>
  </details>
</div>
</body>
</html>